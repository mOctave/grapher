package ib.grapher;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * A class which loosely "holds" any number of Cells in a doubly linked list.
 * As well as calculating a statistical report of the series and holding
 * references to its first and last Cells, a Series also contains an iterator
 * to make it easier to loop through the whole series at once.
 */
public class Series implements Iterable<Cell> {
	// MARK: Constructor
	/**
	 * A constructor that initializes this series, as well as adding a set
	 * number of empty cells to it. All series should always have at least
	 * one cell in them at all times.
	 * @param cells The number of cells to be added. This should be at least
	 * 1. If it is 0 or less, it will be ignored.
	 */
	public Series(int cells) {
		name = "Untitled Series";
		statistics = new HashMap<>();

		Cell c = new Cell();
		firstCell = c;
		lastCell = c;
		c.setSeries(this);
		c.setIndex(0);

		for(int i = 0; i < cells - 1; i++) {
			firstCell.insertCellAfter(new Cell());
		}

		header = new SeriesHeader(this);
	}



	// MARK: Properties
	/** The name of this series. */
	private String name;
	/** The first cell in this series. */
	private Cell firstCell;
	/** The last cell in this series. */
	private Cell lastCell;
	/** A collection of autogenerated statistics about this series. */
	private Map<String, Double> statistics;


	// GUI
	/** This series' header cell. */
	private final SeriesHeader header;



	/**
	 * Creates an iterator for this series.
	 * @return The created {@link java.util.Iterator}
	 */
	@Override
	public Iterator<Cell> iterator() {
		Iterator<Cell> iterator = new Iterator<Cell>() {
			private Cell c = null;

			@Override
			public boolean hasNext() {
				if (c == null) {
					return Series.this.firstCell != null;
				} else {
					return (c.getNext() != null);
				}
			}

			@Override
			public Cell next() {
				if (c == null) {
					c = Series.this.firstCell;
				} else {
					c = c.getNext();
				}
				return c;
			}
		};
		return iterator;
	}



	/**
	 * Saves this series header to the output file, overwriting an existing
	 * entry for the series. If this series has not yet been added,
	 * {@link FileDataManager#encodeForInsertion(Series)} should be used instead.
	 */
	public void save() {
		System.out.println("SAVE: Series");
		int index = Main.getDataTable().indexOf(this);

		int offset = FileDataManager.getOffset(
			FileDataManager.SERIES,
			index
		);

		Byte[] ba = Main.stringToByteArray(name, 64);

		FileDataManager.writeByteList(Arrays.asList(ba), offset);
	}



	/**
	 * Searches this series for cells with a particular value, returning a
	 * {@link java.util.List} of any matches
	 * @param s The string to search for
	 * @return A list of cells whose values exactly match the search criteria
	 */
	public List<Cell> search(String s) {
		List<Cell> matches = new ArrayList<>();
		for (Cell c : this) {
			if (c.getValue().equals(s))
				matches.add(c);
			c = c.getNext();
		}
		return matches;
	}



	/**
	 * Calculates a statistical summary of this series, storing the value in
	 * {@link #statistics} for later retrieval.
	 */
	public void calculateStatistics() {
		double min = Integer.MAX_VALUE;
		double max = Integer.MIN_VALUE;
		double sum = 0.;
		int nonEmpty = 0;
		int numeric = 0;
		for (Cell c : this) {
			try {
				double numVal = c.getNumeric();

				numeric++;

				// A value can be both the highest and lowest in a data set.
				if (numVal > max)
					max = numVal;
				if (numVal < min)
					min = numVal;
				
				sum += numVal;

			} catch (NumberFormatException e) {
				// Perfectly valid situation, just don't run analytics.
			}

			if (!c.getValue().equals(""))
				nonEmpty++;
		}

		// Go again for variance and SD
		double varianceSum = 0.;
		for (Cell c : this) {
			try {
				double numVal = c.getNumeric();

				varianceSum += Math.pow(numVal - sum / numeric, 2);
			} catch (NumberFormatException e) {
				// Perfectly valid situation, just don't run analytics.
			}
		}

		double variance = varianceSum / numeric;

		statistics.put("Non-Empty Cells", (double) nonEmpty);
		statistics.put("Numeric Values", (double) numeric);
		statistics.put("Sum", sum);
		statistics.put("Mean", sum / numeric);

		// This won't work with full datasets containing only the max/min
		// integer values, but I can't imagine anyone would ever use such
		// a data set.
		if (min == Integer.MAX_VALUE || max == Integer.MIN_VALUE) {
			statistics.put("Minimum", null);
			statistics.put("Maximum", null);
			statistics.put("Range", null);
		} else {
			statistics.put("Minimum", min);
			statistics.put("Maximum", max);
			statistics.put("Range", max - min);
		}

		statistics.put("Variance", variance);
		statistics.put("Standard Deviation", Math.sqrt(variance));
	}




	/**
	 * Returns a string representation of this series, in the form
	 * {@code <series name> (<index>)}
	 * @return A string representation of this series
	 */
	@Override
	public String toString() {
		int index = Main.getDataTable().indexOf(this);
		if (index > -1) {
			return String.format("%s (#%d)", name, index + 1);
		} else {
			return name;
		}
	}



	// MARK: Convenience
	/**
	 * Calculates the length of the series based off of the index of the last
	 * cell in it.
	 * @return The length of this series
	 */
	public int length() {
		return lastCell.getIndex() + 1;
	}



	/**
	 * Gets a given statistic about this series.
	 * @param key The key to search {@link #statistics} for
	 * @return The value of the statistic, as an double-formatted string
	 */
	public String getStatistic(String key) {
		try {
			return Double.toString(statistics.get(key));
		} catch (NullPointerException e) {
			return "N/A";
		}
	}



	/**
	 * Gets a given statistic about this series, formatting it as an integer
	 * rather than as a double.
	 * @param key The key to search {@link #statistics} for
	 * @return The value of the statistic, as an integer-formatted string
	 */
	public String getStatisticAsInt(String key) {
		try {
			return Integer.toString((int) (double) statistics.get(key));
		} catch (NullPointerException e) {
			return "N/A";
		}
	}



	// MARK: Getters / Setters
	/**
	 * Getter: Gets the name of this series.
	 * @return {@link #name}
	 */
	public String getName() {
		return name;
	}

	/**
	 * Setter: Changes the name of this series, and updates the series' text
	 * header accordingly.
	 * @param name The new value for {@link #name}
	 */
	public void setName(String name) {
		this.name = name;
		header.getTextField().setText(name);
		save();
	}



	/**
	 * Getter: Gets the first (top) cell in this series.
	 * @return {@link #firstCell}
	 */
	public Cell getFirst() {
		return firstCell;
	}

	/**
	 * Setter: Changes which cell is first in this series.
	 * @param firstCell The new {@link #firstCell} for the series
	 */
	public void setFirst(Cell firstCell) {
		this.firstCell = firstCell;
	}



	/**
	 * Getter: Gets the last (bottom) cell in this series.
	 * @return {@link #lastCell}
	 */
	public Cell getLast() {
		return lastCell;
	}

	/**
	 * Setter: Changes which cell is last in this series.
	 * @param lastCell The new {@link #lastCell} for the series
	 */
	public void setLast(Cell lastCell) {
		this.lastCell = lastCell;
	}

	// Statistics have neither getters nor setters, as they are set by this
	// class and are read individually (see the methods in the Convenience)
	// section.


	// GUI
	/**
	 * Getter: Returns this series' header object.
	 * @return {@link #header}
	 */
	public SeriesHeader getHeader() {
		return header;
	}
}

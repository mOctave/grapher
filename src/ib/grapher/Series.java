package ib.grapher;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * A class which loosely "holds" any number of Cells in a doubly linked list.
 * As well as calculating a statistical report of the series and holding
 * references to its first and last Cells, a Series also contains an iterator
 * to make it easier to loop through the whole series at once.
 */
public class Series implements Iterable<Cell> {
	/**
	 * A constructor that initializes this series, as well as adding a set
	 * number of empty cells to it. All series should always have at least
	 * one cell in them at all times.
	 * @param cells The number of cells to be added. This should be at least
	 * 1. If it is 0 or less, it will be ignored.
	 */
	public Series(int cells) {
		// Non-GUI initialization
		name = "Untitled Series";
		statistics = new HashMap<>();

		Cell c = new Cell();
		firstCell = c;
		lastCell = c;
		c.setSeries(this);
		c.setIndex(0);

		for(int i = 0; i < cells - 1; i++) {
			firstCell.insertCellAfter(new Cell());
		}

		header = new SeriesHeader(this);
	}


	/** This series' header cell. */
	private SeriesHeader header;
	/** The name of this series. */
	private String name;
	/** The first cell in this series. */
	private Cell firstCell;
	/** The last cell in this series. */
	private Cell lastCell;
	/** A collection of autogenerated statistics about this series. */
	private Map<String, Double> statistics;

	/**
	 * Creates an iterator for this series.
	 * @return The created {@link java.util.Iterator}
	 */
	@Override
	public Iterator<Cell> iterator() {
		Iterator<Cell> iterator = new Iterator<Cell>() {
			private Cell c = null;

			@Override
			public boolean hasNext() {
				if (c == null) {
					return Series.this.firstCell != null;
				} else {
					return (c.getNext() != null);
				}
			}

			@Override
			public Cell next() {
				if (c == null) {
					c = Series.this.firstCell;
				} else {
					c = c.getNext();
				}
				return c;
			}
		};
		return iterator;
	}

	/**
	 * Searches this series for cells with a particular value, returning a
	 * {@link java.util.List} of any matches
	 * @param s The string to search for
	 * @return A list of cells whose values exactly match the search criteria
	 */
	public List<Cell> search(String s) {
		List<Cell> matches = new ArrayList<>();
		for (Cell c : this) {
			if (c.getValue().equals(s))
				matches.add(c);
			c = c.getNext();
		}
		return matches;
	}

	/**
	 * Gets the length of the series based off of the index of the last cell in
	 * it.
	 * @return The length of this series.
	 */
	public int length() {
		return lastCell.getIndex() + 1;
	}

	/**
	 * Calculates a statistical summary of this series, storing the value in
	 * {@link #statistics} for later retrieval.
	 */
	public void calculateStatistics() {
		double min = Integer.MAX_VALUE;
		double max = Integer.MIN_VALUE;
		double sum = 0;
		int nonEmpty = 0;
		int numeric = 0;
		for (Cell c : this) {
			try {
				double numVal = c.getNumeric();

				numeric++;

				// A value can be both the highest and lowest in a data set.
				if (numVal > max)
					max = numVal;
				if (numVal < min)
					min = numVal;
				
				sum += numVal;

			} catch (NumberFormatException e) {
				// Perfectly valid situation, just don't run analytics.
			}

			if (!c.getValue().equals(""))
				nonEmpty++;
		}

		statistics.put("Non-Empty Cells", (double) nonEmpty);
		statistics.put("Numeric Values", (double) numeric);
		statistics.put("Sum", sum);
		statistics.put("Mean", sum / numeric);

		// This won't work with full datasets containing only the max/min
		// integer values, but I can't imagine anyone would ever use such
		// a data set.
		if (min == Integer.MAX_VALUE || max == Integer.MIN_VALUE) {
			statistics.put("Minimum", null);
			statistics.put("Maximum", null);
			statistics.put("Range", null);
		} else {
			statistics.put("Minimum", min);
			statistics.put("Maximum", max);
			statistics.put("Range", max - min);
		}
	}

	@Override
	public String toString() {
		int index = Main.getDataTable().indexOf(this);
		if (index > -1) {
			return String.format("%s (#%d)", name, index + 1);
		} else {
			return name;
		}
	}

	// Getters and setters

	/**
	 * @return The {@link SeriesHeader} object for this series.
	 */
	public SeriesHeader getHeader() {
		return header;
	}

	/**
	 * Gets the name of this series.
	 * @return the {@link java.lang.String} name of this series
	 */
	public String getName() {
		return name;
	}

	/**
	 * Changes the name of this series.
	 * @param s the new name of this series
	 */
	public void setName(String s) {
		name = s;
		header.getTextField().setText(s);
	}

	/**
	 * Gets the first (top) cell in this series.
	 * @return A reference to the first {@link Cell} object in this series
	 */
	public Cell getFirst() {
		return firstCell;
	}

	/**
	 * Changes which cell is the first one in this series
	 * @param c The new {@link Cell} object to place at the top of this series
	 */
	public void setFirst(Cell c) {
		firstCell = c;
	}

	/**
	 * Gets the last (bottom) cell in this series.
	 * @return A reference to the last {@link Cell} object in this series
	 */
	public Cell getLast() {
		return lastCell;
	}

	/**
	 * Changes which cell is the last one in this series
	 * @param c The new {@link Cell} object to place at the bottom of this series
	 */
	public void setLast(Cell c) {
		lastCell = c;
	}

	/**
	 * Gets a given statistic about this series.
	 * @param key The key to search {@link #statistics} for
	 */
	public String getStatistic(String key) {
		try {
			return Double.toString(statistics.get(key));
		} catch (NullPointerException e) {
			return "N/A";
		}
	}

	/**
	 * Gets a given statistic about this series, formatting it as an integer
	 * rather than as a double.
	 * @param key The key to search {@link #statistics} for
	 */
	public String getStatisticAsInt(String key) {
		try {
			return Integer.toString((int) (double) statistics.get(key));
		} catch (NullPointerException e) {
			return "N/A";
		}
	}

	// Statistics are calculated by the series object itself, therefore they do
	// not have a setter method.
}
